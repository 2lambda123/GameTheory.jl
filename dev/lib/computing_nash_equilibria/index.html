<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computing Nash Equilibria · Games.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Games.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../base_types_and_methods/">Base Types and Methods</a></li><li><a class="toctext" href="../game_generators/">Game Generators</a></li><li class="current"><a class="toctext" href>Computing Nash Equilibria</a><ul class="internal"><li><a class="toctext" href="#Exported-1">Exported</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li><li><a class="toctext" href="../repeated_games/">Repeated Games</a></li><li><a class="toctext" href="../">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Computing Nash Equilibria</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/Games.jl/blob/master/docs/src/lib/computing_nash_equilibria.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Computing Nash Equilibria</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="computing_nash_equilibria-1" href="#computing_nash_equilibria-1">Computing Nash Equilibria</a></h1><h2><a class="nav-anchor" id="Exported-1" href="#Exported-1">Exported</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Games.pure_nash-Tuple{NormalFormGame}" href="#Games.pure_nash-Tuple{NormalFormGame}"><code>Games.pure_nash</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">pure_nash(nfg; ntofind=Inf, tol=1e-8)</code></pre><p>Finds all pure action Nash equilibria for a normal form game. It returns an empty array if there is no pure action Nash.</p><p>Currently uses a brute force algorithm, but that hopefully will change in the future.</p><p><strong>Arguments</strong></p><ul><li><code>nfg::NormalFormGame</code>: Instance of N-player NormalFormGame.</li><li><code>ntofind::Inf</code>: Maximal number of pure action Nash equilibria to be found; default is <code>prod(nfg.nums_actions)</code>.</li><li><code>tol::Float64</code> : Tolerance to be used to determine best response actions.</li></ul><p><strong>Returns</strong></p><ul><li><code>ne::Vector{NTuple{N,Int}}</code>: Vector of pure action Nash equilibria.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/Games.jl/blob/41505a6c01d20302c525924023bacc7850ca977b/src/pure_nash.jl#L1-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Games.support_enumeration-Union{Tuple{NormalFormGame{2,T}}, Tuple{T}} where T" href="#Games.support_enumeration-Union{Tuple{NormalFormGame{2,T}}, Tuple{T}} where T"><code>Games.support_enumeration</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">support_enumeration(g)</code></pre><p>Compute mixed-action Nash equilibria with equal support size for a 2-player normal form game by support enumeration. For a non-degenerate game input, these are all the Nash equilibria.</p><p>The algorithm checks all the equal-size support pairs; if the players have the same number n of actions, there are 2n choose n minus 1 such pairs. This should thus be used only for small games.</p><p><strong>Arguments</strong></p><ul><li><code>g::NormalFormGame{2,T}</code>: 2-player NormalFormGame instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Vector{NTuple{2,Vector{S}}}</code>: Mixed-action Nash equilibria that are found, where <code>S</code> is Float if <code>T</code> is Int or Float, and Rational if <code>T</code> is Rational.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/Games.jl/blob/41505a6c01d20302c525924023bacc7850ca977b/src/support_enumeration.jl#L19-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Games.support_enumeration_task-Tuple{Channel,NormalFormGame{2,T} where T&lt;:Real}" href="#Games.support_enumeration_task-Tuple{Channel,NormalFormGame{2,T} where T&lt;:Real}"><code>Games.support_enumeration_task</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">support_enumeration_task(c, g)</code></pre><p>Task version of <code>support_enumeration</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::Channel</code>: Channel to be binded with the support enumeration task.</li><li><code>g::NormalFormGame{2}</code>: 2-player NormalFormGame instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Task</code>: Runnable task for generating Nash equilibria.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/Games.jl/blob/41505a6c01d20302c525924023bacc7850ca977b/src/support_enumeration.jl#L51-L64">source</a></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Games._indiff_mixed_action!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,1},Array{T,1},Array{T,2} where T,Array{Int64,1},Array{Int64,1}}} where T&lt;:Real" href="#Games._indiff_mixed_action!-Union{Tuple{T}, Tuple{Array{T,2},Array{T,1},Array{T,1},Array{T,2} where T,Array{Int64,1},Array{Int64,1}}} where T&lt;:Real"><code>Games._indiff_mixed_action!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_indiff_mixed_action!(A, b, out, payoff_matrix, own_supp, opp_supp)</code></pre><p>Given a player&#39;s payoff matrix <code>payoff_matrix</code>, an array <code>own_supp</code> of this player&#39;s actions, and an array <code>opp_supp</code> of the opponent&#39;s actions, each of length k, compute the opponent&#39;s mixed action whose support equals <code>opp_supp</code> and for which the player is indifferent among the actions in <code>own_supp</code>, if any such exists. Return <code>true</code> if such a mixed action exists and actions in <code>own_supp</code> are indeed best responses to it, in which case the outcome is stored in <code>out</code>; <code>false</code> otherwise. Arrays <code>A</code> and <code>b</code> are used in intermediate steps.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: Matrix of shape (k+1, k+1) used in intermediate steps, where <code>T&lt;:Real</code>.</li><li><code>b::Vector{T}</code>: Vector of length k+1 used in intermediate steps, where <code>T&lt;:Real</code>.</li><li><code>out::Vector{T}</code>: Vector of length k to store the nonzero values of the desired mixed action, where <code>T&lt;:Real</code>.</li><li><code>payoff_matrix::Matrix</code>: The player&#39;s payoff matrix, of shape (m, n).</li><li><code>own_supp::Vector{Int}</code>: Vector containing the player&#39;s action indices, of length k.</li><li><code>opp_supp::Vector{Int}</code>: Vector containing the opponent&#39;s action indices, of length k.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Bool</code>: <code>true</code> if a desired mixed action exists and <code>false</code> otherwise.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/Games.jl/blob/41505a6c01d20302c525924023bacc7850ca977b/src/support_enumeration.jl#L153-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Games._support_enumeration_producer-Union{Tuple{T}, Tuple{Channel,Tuple{Array{T,2},Array{T,2}}}} where T&lt;:Real" href="#Games._support_enumeration_producer-Union{Tuple{T}, Tuple{Channel,Tuple{Array{T,2},Array{T,2}}}} where T&lt;:Real"><code>Games._support_enumeration_producer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">_support_enumeration_producer(c, payoff_matrices)</code></pre><p>Main body of <code>support_enumeration_task</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::Channel</code>: Channel to be binded with the support enumeration task.</li><li><code>payoff_matrices::NTuple{2,Matrix{T}}</code>: Payoff matrices of player 1 and player 2, where <code>T&lt;:Real</code>.</li></ul><p><strong>Puts</strong></p><ul><li><code>NTuple{2,Vector{S}}</code>: Tuple of Nash equilibrium mixed actions, where <code>S</code> is Float if <code>T</code> is Int or Float, and Rational if <code>T</code> is Rational.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/Games.jl/blob/41505a6c01d20302c525924023bacc7850ca977b/src/support_enumeration.jl#L77-L92">source</a></section><footer><hr/><a class="previous" href="../game_generators/"><span class="direction">Previous</span><span class="title">Game Generators</span></a><a class="next" href="../repeated_games/"><span class="direction">Next</span><span class="title">Repeated Games</span></a></footer></article></body></html>
